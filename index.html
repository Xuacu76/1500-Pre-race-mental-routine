ort { Clock, CheckCircle, Target, Zap, ChevronDown, ChevronUp, AlertTriangle } from 'lucide-react';

// --- Routine Data Structure ---
const routines = {
  '30-MINUTE ROUTINE': {
    time: 30 * 60, // Total time in seconds
    steps: [
      { name: 'Reset Body-Mind (Light movement, 3 deep breaths)', duration: 3 * 60, cues: 'Inner cue: "I\'m here because I trained for this."' },
      { name: 'Mental Check-In (Assess activation level)', duration: 2 * 60, cues: 'If low: short strides/drills. If high: breathing + relax shoulders/jaw.' },
      { name: 'Goal & Purpose Reminder (Tactical goal & Deep purpose)', duration: 3 * 60, cues: 'Deep purpose example: "Top 3 in January. I am willing to suffer for it."' },
      { name: 'Race Plan Review (Plan A - Normal Start)', duration: 3 * 60, cues: '150m: position. Mid: relaxed. 900m: controlled increase. 400m: decisive move ("Head down & hunt").' },
      { name: 'Race Plan Review (Plan B - Chaotic Start)', duration: 3 * 60, cues: 'Option 1: move up early. Option 2: stay outside pack ("washing machine"). Cue: "Execute Plan B."' },
      { name: 'Short Visualization (Version 1 & 2)', duration: 4 * 60, cues: 'V1: clean start, strong finish. V2: messy start, calm response.' },
      { name: 'Three Key Mental Cues Memorization', duration: 4 * 60, cues: 'Start: "You trained for this." Pain: "Welcome it. Keep going." Final 400: "Head down & push."' },
    ],
  },
  '5-MINUTE ROUTINE': {
    time: 5 * 60,
    steps: [
      { name: 'Micro Activation (Short strides, light drills)', duration: 2 * 60, cues: 'Cue: "My body is ready."' },
      { name: 'Breathing + Posture (3 deep breaths)', duration: 1 * 60, cues: 'Champion posture: open chest, relaxed face. Cue: "I trust myself."' },
      { name: 'Three Rules of the Day (Position, Pain, Focus)', duration: 2 * 60, cues: '1) Position: "Find my spot." 2) Pain: "It\'s my signal." 3) Focus: "Back to the plan."' },
    ],
  },
  '1-MINUTE ROUTINE (START LINE)': {
    time: 1 * 60,
    steps: [
      { name: 'Body Anchor (Ground feet, relax jaw, gesture)', duration: 15, cues: 'Small habitual gesture (tap chest/wrist).' },
      { name: 'Last 3 Breaths', duration: 15, cues: 'B1: "I\'m ready." B2: "I trained for this." B3: "I accept the pain. I go for it."' },
      { name: 'Final Mantra Selection', duration: 15, cues: 'Choose one: "Calm and dangerous," "Stick & kick," "Head down & fight," or "Strong and steady."' },
      { name: 'Final Commitment', duration: 15, cues: '"Whatever position I\'m in, with 400m to go, I will go all-in."' },
    ],
  },
};

const formatTime = (seconds) => {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
};

const App = () => {
  const [raceTime, setRaceTime] = useState('');
  const [raceStart, setRaceStart] = useState(null); // Date object for race start time
  const [currentTime, setCurrentTime] = useState(new Date());
  const [activeRoutine, setActiveRoutine] = useState(null); // '30-MINUTE ROUTINE', '5-MINUTE ROUTINE', '1-MINUTE ROUTINE (START LINE)'
  const [currentStepIndex, setCurrentStepIndex] = useState(0);
  const [isPaused, setIsPaused] = useState(false);
  const [showRoutines, setShowRoutines] = useState(false);

  const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
  const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
  const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

  // --- Utility Functions for Firebase Storage (using a simple mock for now, but following structure) ---
  // In a real Canvas environment, this would use the imported Firebase functions.
  // For the sake of the single-file React component in a simulated environment,
  // we'll assume a storage mechanism will be integrated later or use component state only.

  // --- Timing Logic ---
  useEffect(() => {
    const timer = setInterval(() => {
      setCurrentTime(new Date());
    }, 1000);
    return () => clearInterval(timer);
  }, []);

  const calculateStartTime = useCallback((routineKey) => {
    if (!raceStart) return null;
    const routineDuration = routines[routineKey].time;
    // Calculate the exact time the routine should START
    return new Date(raceStart.getTime() - routineDuration * 1000);
  }, [raceStart]);

  const targetRoutineStartTimes = useMemo(() => {
    if (!raceStart) return {};
    return {
      '30-MINUTE ROUTINE': calculateStartTime('30-MINUTE ROUTINE'),
      '5-MINUTE ROUTINE': calculateStartTime('5-MINUTE ROUTINE'),
      '1-MINUTE ROUTINE (START LINE)': calculateStartTime('1-MINUTE ROUTINE (START LINE)'),
    };
  }, [raceStart, calculateStartTime]);

  // Logic for the countdown timer within an active step
  const activeStep = activeRoutine ? routines[activeRoutine].steps[currentStepIndex] : null;
  const totalRoutineDuration = activeRoutine ? routines[activeRoutine].time : 0;
  const routineStartTime = activeRoutine ? targetRoutineStartTimes[activeRoutine] : null;

  const currentStepElapsedTime = useMemo(() => {
    if (!routineStartTime || isPaused) return 0;
    const timeElapsedSinceRoutineStart = (currentTime.getTime() - routineStartTime.getTime()) / 1000;

    let timeInPreviousSteps = 0;
    for (let i = 0; i < currentStepIndex; i++) {
      timeInPreviousSteps += routines[activeRoutine].steps[i].duration;
    }

    return Math.max(0, timeElapsedSinceRoutineStart - timeInPreviousSteps);
  }, [currentTime, routineStartTime, activeRoutine, currentStepIndex, isPaused]);

  const currentStepRemainingTime = activeStep ? Math.max(0, activeStep.duration - currentStepElapsedTime) : 0;
  const totalRoutineRemainingTime = useMemo(() => {
    if (!routineStartTime) return totalRoutineDuration;
    const elapsed = (currentTime.getTime() - routineStartTime.getTime()) / 1000;
    return Math.max(0, totalRoutineDuration - elapsed);
  }, [currentTime, routineStartTime, totalRoutineDuration]);


  // Logic to auto-advance the step
  useEffect(() => {
    if (!activeRoutine || isPaused || !activeStep || !routineStartTime) return;

    if (currentStepElapsedTime >= activeStep.duration) {
      if (currentStepIndex < routines[activeRoutine].steps.length - 1) {
        // Move to next step
        setCurrentStepIndex(prev => prev + 1);
      } else {
        // Routine is complete
        console.log(`${activeRoutine} complete.`);
        const nextRoutineKey = getNextRoutineKey(activeRoutine);
        if (nextRoutineKey) {
          // Auto-start next routine
          setActiveRoutine(nextRoutineKey);
          setCurrentStepIndex(0);
        } else {
          // All routines complete
          setActiveRoutine(null);
        }
      }
    }
  }, [currentStepElapsedTime, activeRoutine, currentStepIndex, activeStep, isPaused, routineStartTime]);


  // Helper to get the key of the next routine
  const getNextRoutineKey = (currentKey) => {
    const keys = Object.keys(routines);
    const currentIndex = keys.indexOf(currentKey);
    return keys[currentIndex + 1] || null;
  };

  // --- Handlers ---
  const handleTimeInput = (e) => {
    setRaceTime(e.target.value);
    const date = new Date();
    const [hours, minutes] = e.target.value.split(':').map(Number);
    if (!isNaN(hours) && !isNaN(minutes)) {
      date.setHours(hours, minutes, 0, 0);
      setRaceStart(date);
    } else {
      setRaceStart(null);
    }
  };

  const handleStartRoutine = (key) => {
    if (!raceStart) return;
    setActiveRoutine(key);
    setCurrentStepIndex(0);
    setIsPaused(false);
  };

  const handleNextStep = () => {
    if (!activeRoutine) return;
    if (currentStepIndex < routines[activeRoutine].steps.length - 1) {
      setCurrentStepIndex(prev => prev + 1);
    } else {
      // End routine
      const nextRoutineKey = getNextRoutineKey(activeRoutine);
      if (nextRoutineKey) {
        setActiveRoutine(nextRoutineKey);
        setCurrentStepIndex(0);
      } else {
        setActiveRoutine(null);
      }
    }
    // Adjust routine start time to align with manual skip (simulating time jump)
    if (routineStartTime) {
      let timeInCompletedSteps = 0;
      for (let i = 0; i <= currentStepIndex; i++) {
        timeInCompletedSteps += routines[activeRoutine].steps[i].duration;
      }
      setRaceStart(prevRaceStart => {
        // The new race start time should be what it was, minus the total time of the steps we skipped ahead
        // This is complex for a real timer, simpler solution: stop the timer and update only the step index,
        // which we're doing. The automatic advance handles the rest based on the original race start time.
      });
    }
  };

  // --- Render Helpers ---

  const renderRoutineCards = () => (
    <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mt-6">
      {Object.entries(routines).map(([key, data]) => {
        const startTime = targetRoutineStartTimes[key];
        const isScheduled = startTime && currentTime.getTime() < startTime.getTime() + data.time * 1000;
        const isActive = activeRoutine === key;

        return (
          <div
            key={key}
            className={`p-5 rounded-xl shadow-lg transition-all duration-300
              ${isActive ? 'bg-indigo-600 text-white shadow-indigo-500/50 scale-[1.02]' :
                isScheduled ? 'bg-indigo-100 text-indigo-800 hover:bg-indigo-200 cursor-pointer' :
                'bg-gray-100 text-gray-500'
              }`}
            onClick={() => !isActive && isScheduled && handleStartRoutine(key)}
          >
            <div className="flex justify-between items-center mb-3">
              <h3 className={`text-lg font-bold ${isActive ? 'text-white' : 'text-indigo-900'}`}>{key}</h3>
              <div className="flex items-center space-x-2">
                <Clock className={`w-5 h-5 ${isActive ? 'text-white' : 'text-indigo-600'}`} />
                <span className={`text-sm font-semibold ${isActive ? 'text-white' : 'text-indigo-700'}`}>
                  {formatTime(data.time)}
                </span>
              </div>
            </div>
            {raceStart && startTime && (
              <p className={`text-sm font-medium ${isActive ? 'text-indigo-200' : 'text-indigo-600'}`}>
                Starts at: {startTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
              </p>
            )}
            {!raceStart && <p className="text-sm italic">Set race time to schedule.</p>}
          </div>
        );
      })}
    </div>
  );

  const renderActiveRoutine = () => {
    if (!activeRoutine || !activeStep || !routineStartTime) return null;

    const progressPercentage = (currentStepElapsedTime / activeStep.duration) * 100;

    const routineCompletedSteps = routines[activeRoutine].steps.slice(0, currentStepIndex);
    const routineRemainingSteps = routines[activeRoutine].steps.slice(currentStepIndex + 1);

    return (
      <div className="mt-8 p-6 bg-white border border-indigo-200 rounded-xl shadow-2xl">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-2xl font-extrabold text-indigo-800 flex items-center">
            <Zap className="w-6 h-6 mr-2 text-yellow-500" />
            {activeRoutine}
          </h2>
          <div className="flex items-center space-x-4">
            <div className="text-right">
              <p className="text-xs font-medium text-gray-500 uppercase">Routine Time Left</p>
              <p className="text-xl font-bold text-indigo-700">{formatTime(totalRoutineRemainingTime)}</p>
            </div>
            <button
              onClick={() => setIsPaused(!isPaused)}
              className="px-4 py-2 text-sm font-semibold rounded-full transition-colors duration-200"
              style={{ backgroundColor: isPaused ? '#fcd34d' : '#ef4444', color: 'white' }}
            >
              {isPaused ? 'Resume' : 'Pause'}
            </button>
          </div>
        </div>

        {/* Current Step Display */}
        <div className="bg-indigo-50 p-4 rounded-lg border border-indigo-200 mb-6">
          <h3 className="text-lg font-bold text-indigo-900">
            Current Step {currentStepIndex + 1} of {routines[activeRoutine].steps.length}: {activeStep.name}
          </h3>
          <p className="text-4xl font-mono my-2 text-indigo-600">{formatTime(currentStepRemainingTime)}</p>
          <div className="w-full bg-indigo-200 rounded-full h-2.5">
            <div
              className="bg-indigo-600 h-2.5 rounded-full transition-all duration-1000"
              style={{ width: `${Math.min(100, progressPercentage)}%` }}
            ></div>
          </div>
          <p className="text-sm mt-2 text-indigo-700 font-medium">Focus/Cue: {activeStep.cues}</p>

          <button
            onClick={handleNextStep}
            className="mt-4 w-full py-2 bg-indigo-500 text-white font-semibold rounded-lg shadow hover:bg-indigo-600 transition-colors"
          >
            {currentStepIndex < routines[activeRoutine].steps.length - 1 ? 'Skip to Next Step' : 'Mark Routine Complete'}
          </button>
        </div>

        {/* Step List */}
        <div className="max-h-60 overflow-y-auto pr-2">
          {routineCompletedSteps.map((step, index) => (
            <div key={index} className="flex items-center text-sm text-green-600 mb-2">
              <CheckCircle className="w-4 h-4 mr-2 flex-shrink-0" />
              <span className="line-through">{step.name} ({formatTime(step.duration)})</span>
            </div>
          ))}
          <div className="flex items-center text-sm font-semibold text-indigo-800 mb-2 p-1 bg-indigo-100 rounded">
            <Zap className="w-4 h-4 mr-2 flex-shrink-0 text-yellow-600" />
            {activeStep.name} (Active)
          </div>
          {routineRemainingSteps.map((step, index) => (
            <div key={currentStepIndex + 1 + index} className="flex items-center text-sm text-gray-500 mb-2">
              <Clock className="w-4 h-4 mr-2 flex-shrink-0" />
              <span>{step.name} ({formatTime(step.duration)})</span>
            </div>
          ))}
        </div>
      </div>
    );
  };

  const timeToRaceStart = raceStart ? Math.max(0, (raceStart.getTime() - currentTime.getTime()) / 1000) : null;
  const isTimeCritical = timeToRaceStart !== null && timeToRaceStart <= routines['1-MINUTE ROUTINE (START LINE)'].time;

  return (
    <div className="min-h-screen bg-gray-50 p-4 sm:p-8 font-sans">
      <div className="max-w-4xl mx-auto">
        <header className="text-center mb-8">
          <h1 className="text-4xl font-extrabold text-indigo-900 mb-2">
            1500m Mental Prep Navigator
          </h1>
          <p className="text-gray-600">Based on your Sport Psychology Pre-Race Routines.</p>
        </header>

        {/* Race Time and Global Countdown */}
        <div className="bg-white p-6 rounded-xl shadow-lg border border-indigo-100 mb-8">
          <div className="flex flex-col sm:flex-row items-center justify-between">
            <div className="flex items-center space-x-4 mb-4 sm:mb-0">
              <Target className="w-8 h-8 text-indigo-600" />
              <label htmlFor="race-time" className="text-xl font-semibold text-gray-700">Race Start Time:</label>
              <input
                id="race-time"
                type="time"
                value={raceTime}
                onChange={handleTimeInput}
                className="p-2 border-2 border-indigo-300 rounded-lg text-lg font-mono focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 transition-colors"
              />
            </div>
            <div className={`text-right p-3 rounded-lg ${isTimeCritical ? 'bg-red-50 text-red-700 border-red-300 border' : 'bg-indigo-50 text-indigo-700'}`}>
              <p className="text-xs font-medium uppercase">Time To Race Start</p>
              <p className="text-3xl font-extrabold font-mono">
                {timeToRaceStart !== null ? formatTime(timeToRaceStart) : '--:--'}
              </p>
              {isTimeCritical && (
                 <p className="text-xs font-semibold mt-1 flex items-center justify-end">
                    <AlertTriangle className="w-3 h-3 mr-1" />
                    CRITICAL: Enter 1-Min Zone
                 </p>
              )}
            </div>
          </div>
        </div>

        {/* Active Routine Display */}
        {renderActiveRoutine()}

        {/* Scheduled Routines/Manual Start */}
        <div className="mt-8">
          <button
            onClick={() => setShowRoutines(!showRoutines)}
            className="w-full py-3 px-4 bg-indigo-500 text-white font-bold text-lg rounded-xl shadow-md hover:bg-indigo-600 transition-colors flex items-center justify-center"
          >
            {showRoutines ? <ChevronUp className="w-5 h-5 mr-2" /> : <ChevronDown className="w-5 h-5 mr-2" />}
            {showRoutines ? 'Hide Routine Details' : 'View & Manage Pre-Race Routines'}
          </button>
          {showRoutines && (
            <div className="p-6 bg-white rounded-xl shadow-lg border-t border-indigo-200 mt-4">
                <h2 className="text-xl font-bold text-indigo-800 mb-4">Routine Schedule</h2>
                {renderRoutineCards()}
                <p className="mt-6 text-sm text-gray-500 italic">
                    The tracker will guide you through these routines based on the Race Start Time. Click a card to manually start the routine.
                </p>
            </div>
          )}
        </div>

        {/* Detailed Routine Step List (Always visible as reference) */}
        <div className="mt-10 pt-6 border-t border-gray-200">
          <h2 className="text-2xl font-bold text-indigo-900 mb-4">Full Routine Reference</h2>
          {Object.entries(routines).map(([routineKey, routineData]) => (
            <div key={routineKey} className="mb-6 p-4 bg-white rounded-lg shadow-md">
              <h3 className="text-xl font-bold text-indigo-700 mb-3 border-b pb-2">{routineKey} ({formatTime(routineData.time)} total)</h3>
              <ol className="list-decimal ml-5 space-y-3 text-gray-700">
                {routineData.steps.map((step, index) => {
                  const stepStartTime = index === 0 ? routineData.time : routineData.steps.slice(0, index).reduce((acc, s) => acc - s.duration, routineData.time);
                  const stepEndTime = stepStartTime - step.duration;
                  return (
                    <li key={index} className="text-sm">
                      <p className="font-semibold">{step.name} <span className="text-indigo-500">({formatTime(step.duration)})</span></p>
                      <p className="text-xs italic text-gray-500">Approx. Race Time Remaining: T-{formatTime(stepStartTime)} to T-{formatTime(stepEndTime)}</p>
                      <p className="text-xs mt-1 bg-indigo-50 p-2 rounded">{step.cues}</p>
                    </li>
                  );
                })}
              </ol>
            </div>
          ))}
        </div>
      </div>
    </div>
